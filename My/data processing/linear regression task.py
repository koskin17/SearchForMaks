"""Инструкции к заданию.
Возьмите данные по безработице в городе Москва:
video.ittensive.com/python-advanced/data-9753-2019-07-25.utf.csv
Сгруппируйте данные по годам, если в году меньше 6 значений, отбросьте эти годы.
Постройте модель линейной регрессии по годам среднего значения отношения
UnemployedDisabled к UnemployedTotal (процента людей с ограниченными возможностями) за месяц и ответьте,
какое ожидается значение в 2020 году при сохранении текущей политики города Москвы?
Ответ округлите до сотых. Например, 2,31
---
Какое ожидается значение в 2020 году при сохранении текущей политики города Москвы?
1,52
"""
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

# Подключаем файл с данными
data = pd.read_csv("https://video.ittensive.com/python-advanced/data-9753-2019-07-25.utf.csv",
                   delimiter=";")
# Смотрим на данные
print("Пример данных:")
print(data)
print()
print("Пример данных кратко:")
print(data.head())
# Теперь вычисляем среднее значение для каждой строки.
# Для этого добавляем новый столбец в DataFrame и в него вносим среднее значение, как отношение
# UnemployedDisabled к UnemployedTotal
# В результате получаем новую серию из процентов по каждой строке
data["UDP"] = data["UnemployedDisabled"] / data["UnemployedTotal"] * 100
# Смотрим на результат
print()
print("Данные с добавленным столбцом UDP")
print(data)
print("Данные в новом столбце UDP")
print(data["UDP"])
# Группируем данные по году, но с фильтрацией кол-ва значений, которых должно быть не меньше 6, т.е. больше 5.
# Т.е. передаём группу данных и в ней считает кол-во строк, которые вошли в эту группу данных.
# Т.е. все года, в которых меньше 6 записей, отбрасываются.
# Берётся значение столбца, считается кол-во таких значений (т.е. кол-во строк в столбце в этим значением) и оно
# должно быть больше 5
data_group = data.groupby("Year").filter(lambda var1: var1["UDP"].count() > 5)
# Но наложенный фильтр на группу данных возвращает не группу, а сами данные.
# Значит данные нужно заново сгруппировать по году и взять для них, например, среднее значение
data_group = data_group.groupby("Year").mean(numeric_only=True)
# После этого уже можно посмотреть на эти данные
print()
print("Группировка данных по годам с фильтрацией:")
print(data_group)
# Готовим модель линейной регрессии:
# 1. Приводим индексы группы данных к массиву и потом меняем их форму на двумерный массив,
# который нужен для линейной регрессии:
# - np.array делает одномерный массив из заданного списка;
# - reshape делает двумерный массив из списка размеров: размер списка Х 1
x = np.array(data_group.index).reshape(len(data_group.index), 1)
# Для зависимой переменой используем значения столбца "UDP" для каждой группы данных,
# а форма такая же, как и для Х
y = np.array(data_group["UDP"]).reshape(len(data_group.index), 1)
# Данные подготовлены и вызывается метод линейной регрессии - создаём объект линейной регрессии
model = LinearRegression()
# В объект загружаем данные х и y
model.fit(x, y)
# Теперь выводим ответ, т.е. вычисляем предсказываемое значение для 2020 года
# Его тоже приводим к форме двумерного массива, т.е. приводим его к массиву и на этом массиве делаем reshape(1, 1)
# и сразу округляем до 2.
# Для округления нужен метод np.round(). Сам round() для массива np не определён
print(np.round(model.predict(np.array(2020).reshape(1, 1)), 2))
# Получаем ответ - процент безработных людей с ограниченными возможностями среди всех безработных
