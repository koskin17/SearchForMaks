''' Вложенный функции '''


def show():
    print('Функция')

print('До функции')

show()

print('После функции')

show()

def show2():
    x = 7 + z
    return x
z = 7
y = show2()
z = show2() + 9
print('Результат функции: ', z)
print(y)
print('')

print('Параметры и аргументы функции')
def count_list(parametr, parametr2 = False, count = 0): #в этом случае count - это параметр по умолчанию
    if parametr2 == True:
        type_of_element = type(parametr[0])
        for i in parametr:
            count +=1
        return count, type_of_element
    else:
        for i in parametr:
            count += 1
        return count

j = [9, 8, 7, 6]
print(count_list(j))
h = ['a', 'a', 'h']
print(count_list(h))
k = [1, 2, 3, 4]
print(count_list(k))
print(count_list('string'))
print('Второй пример использования функции')

#если в функции нужно один параметр оставить по умолчанию, а второй изменить, то пишется так
def count_list(parametr, parametr2 = False, count = 0): #в этом случае count - это параметр по умолчанию
    if parametr2 == True:
        type_of_element = type(parametr[0])
        for i in parametr:
            count +=1
        return count, type_of_element
    else:
        for i in parametr:
            count += 1
        return count

j = [9, 8, 7, 6]
print(count_list(j, count = -1))
h = ['a', 'a', 'h']
print(count_list(h))
k = [1, 2, 3, 4]
print(count_list(k))
print(count_list('string'))
print('')

print('Передача в функцию переменное количество параметров, т.е. разное')
def name(*args):    #в этом синтаксисе важна именно звёздочка. Она позволяет упаковать аргументы функции в кортеж. ARGS записывается для хорошего тона, чтобы и другие разработчики понимали
    print(args)

print('При передачи нескольких параметров в функцию все они упаковываются в кортеж и выглядят вот так: ')
name(7,9,8,7)
print('Даже если в функцию не передавать аргументы, то ошибки не будет. Будет создан пустой кортеж:')
name()

def name2(w, *args):
    print(w)
    print(args)
'''
если перед параметром со звёздочкой стоит еще один параметр и все они являются неименованными параметрами,
то при передачи нескольких параметров в функцию их распределение будет происходить так:
первый аргумент при передаче в функцию присвоится первому аргументу функции,
все остальные аргументы будут упакованы в кортеж
'''
print('Выглядеть это будет вот так:')
name2(1,2,3)
print('Т.е. при передачи в функцию параметров 1,2,3 - 1 - записалось в первый неименованный аргумент, а 2 и 3 упаковались в кортеж args')
'''
Если в параметрах функции перед звёздочкой стоит 2 и более неименованных параметров,
то при передаче функции параметров при вызове они по порядку присвоятся сначала неименованным параметрам,
а остальные упакуются в кортеж
'''
def name4(w, g, *args, key):
    print(w)
    print(g)
    print(args)
    print(key)
'''
если нужны дополнительные параметры для передачи функции, то они называются "ключевые параметры" и указываются после параметра со звёздочкой,
но для присвоения значениё этому парметру к нему нужно обращаться по имени
'''
name4(1,2,3,4,5,6,key=7)
print('')

'''
пример использования - создание функции создающей из переданного списка новый список, но только с уникальными значениями
'''
# создаём функцию для перебора списков и выделения уникальных значений
def exclusive_item(*args):
# сначала вводим / определяем новый список, в который будут записываться уникальные значения. Он изначально пустой
    new_list = []
# создаём цикл для 
    for i in args:
# создаём новый цикл с новой переменной, который будет перебирать полученный список в переменной i
        for y in i:                     
            if y not in new_list:       # прописываем условие - если значение Y не в списке new_list, т.е. его  еще нет в списка и значии оно уникальное,
                                        #
                                        # то переходим к выполнению цикла ниже
                new_list.append(y)      # добавляем оператором APPEND значение переменной Y в новый список new_list при выполнении вышеуказанного условия
    return new_list                     # возвращаем в качестве результата работы функции новый список new_list

z = [9,8,7]                             # берём 1-ый список для обработки
x = [8,8,9,7,6,5]                       # берём 2-ой список для обработки
c = [1,2,3,4,5,6,7,7]                   # берём 3-ий список для обработки

t = exclusive_item(z,x,c)               # вводим переменную, значением которой будет результат работы функции с переданными ей для работы тремя списками.
print('Изначальные списки: ', z, x, c)
print('Результат работы функции и новый сформированный список из уникальных значений: ', t)     # отображаем результат работы функции, записанный в переменную t
print('')

print('Расширяем возможности функции и делаем новый список еще и сортированным ')
def exclusive_item(*args, key = False):              
    new_list = []                       
    for i in args:                      
        for y in i:                     
            if y not in new_list:       
                new_list.append(y)
    if key == True:
        new_list.sort()
    return new_list                     

z = [9,8,7]                             
x = [8,8,9,7,6,5]                       
c = [1,2,3,4,5,6,7,7]                   

t = exclusive_item(z,x,c, key = True)
print('Изначальные списки: ', z, x, c)
print('Результат работы функции и новый сформированный список из уникальных значений: ', t)     # отображаем результат работы функции, записанный в переменную t
print('')

print('Области видимости переменным в функциях')
x = 5

def name():
    global x    # слово global означается, что мы не создаём нову переменную Х
                # а ссылаемся на глобальную переменную и изменения вносим в неё
    x = 100
    print(x)

name()
print(x)

def name2():
    print(x)

name2()

# структурируем код, избегая захламления кода глобальными переменными
y = 100

def name():
    y = 200
    return name2(y) # в этом случае полученное значение Y при отбработке функции NAMУ
                    # передается в функцию NAME2, которую мы вызываем
                    # саму функцию NAME2 мы описываем ниже
def name2(par):     # в этом случае указываем, что функция NAME2 получает на входе параметр
    print(par)
print('Первначальное значение переменной Y:', y)
print('Значение переменной Y после вызова функции NAME, которое вызываем функцию NAME2 и передает ей значение переменной Y:')
name()

print('Следующий пример объявления функции в функции')
x = 5
def name3():
    x = 10
    def name4():
        nonlocal x  # слово nonlocal позволяет не создавать еще одну переменную Х (локальную),
                    # а менять значение уже имеющейся переменной Х из материнской функции
        x = 100
        print(x)

    name4()
    print(x)
name3()
print(x)
print('')

